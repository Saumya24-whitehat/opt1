(function (a, b) {
  "object" == typeof exports && "undefined" != typeof module
    ? b(exports)
    : "function" == typeof define && define.amd
    ? define(["exports"], b)
    : ((a = "undefined" == typeof globalThis ? a || self : globalThis),
      b((a.Datafeeds = {})));
})(this, function (a) {
  "use strict";
  function b(a, b, c) {
    var d = b.toLowerCase(),
      e = d.split(c),
      f = a.split(c),
      g = e.indexOf("mm"),
      h = e.indexOf("dd"),
      i = e.indexOf("yyyy"),
      j = parseInt(f[i]);
    100 > j && (j += 2e3);
    var k = parseInt(f[g]);
    return 10 > k && (k = "0" + k), j + "-" + k + "-" + f[h];
  }
  function c(a) {
    var c,
      a = a.toString(),
      d = a.substring(0, 2),
      e = a.substring(2, 5),
      f = a.substring(5, 7);
    "JAN" == e
      ? (c = 1)
      : "FEB" == e
      ? (c = 2)
      : "MAR" == e
      ? (c = 3)
      : "APR" == e
      ? (c = 4)
      : "MAY" == e
      ? (c = 5)
      : "JUN" == e
      ? (c = 6)
      : "JUL" == e
      ? (c = 7)
      : "AUG" == e
      ? (c = 8)
      : "SEP" == e
      ? (c = 9)
      : "OCT" == e
      ? (c = 10)
      : "NOV" == e
      ? (c = 11)
      : "DEC" == e && (c = 12);
    var g = d + "/" + c + "/" + f,
      h = b(g, "dd/MM/yyyy", "/");
    return h;
  }
  function d(a) {
    var b = [];
    return (
      $.ajax({
        url: "/opt/hcharts/stx8req/php/getMinDate_Straddle_TV.php",
        type: "POST",
        cache: !1,
        async: !1,
        data: { symbol: a },
        success: function (a) {
          b.push(a);
        },
      }),
      b[0]
    );
  }
  function e() {}
  function f(a) {
    if (a === void 0) return "";
    return "string" == typeof a ? a : a.message;
  }
  function g(a, b) {
    let c = 0;
    return (
      (c =
        "D" === a || "1D" === a
          ? b
          : "M" === a || "1M" === a
          ? 31 * b
          : "W" === a || "1W" === a
          ? 7 * b
          : (b * parseInt(a)) / 1440),
      60 * (60 * (24 * c))
    );
  }
  function h(a, b, c, d) {
    const e = a[b];
    return Array.isArray(e) && (!d || Array.isArray(e[0])) ? e[c] : e;
  }
  function i(a, b, c) {
    return (
      a +
      (b === void 0 ? "" : "_%|#|%_" + b) +
      (c === void 0 ? "" : "_%|#|%_" + c)
    );
  }
  function j(a, b) {
    return a === void 0 ? b : a;
  }
  function k() {
    var a,
      b,
      c,
      d,
      e = new Date().toISOString().slice(0, 10);
    return (
      e > default_expiry_date
        ? "XX" == default_option_type
          ? ((a = "Futures_Latest"),
            (b = "Options_Latest"),
            (c = ""),
            (d = "Options_Hist"))
          : ((a = "Futures_Latest"),
            (b = "Options_Latest"),
            (c = "Futures_Hist"),
            (d = ""))
        : "XX" == default_option_type
        ? ((a = ""),
          (b = "Options_Latest"),
          (c = "Futures_Hist"),
          (d = "Options_Hist"))
        : ((a = "Futures_Latest"),
          (b = ""),
          (c = "Futures_Hist"),
          (d = "Options_Hist")),
      {
        supports_search: !0,
        supports_group_request: !1,
        supported_resolutions: [
          "1",
          "2",
          "3",
          "4",
          "5",
          "10",
          "15",
          "20",
          "30",
          "60",
          "120",
          "240",
          "1D",
          "1W",
          "1M",
          "75",
        ],
        supports_marks: !1,
        supports_timescale_marks: !1,
        exchanges: [{ value: "NSE", name: "NSE", desc: "NSE" }],
        symbols_types: [
          { name: "Futures (Latest)", value: a },
          { name: "Options (Latest)", value: b },
          { name: "Futures (Historical)", value: c },
          { name: "Options (Historical)", value: d },
        ],
      }
    );
  }
  class l {
    constructor(a, b) {
      (this._datafeedUrl = a), (this._requester = b);
    }
    getBars(a, b, e, g) {
      let { from: h, to: i, firstDataRequest: j } = e;
      var fullsymbol = a.name,
        k = fullsymbol.split("+")[0],
        l = a.name,
        noQuantity = l.split("+"),
        m = noQuantity[0].split(":"),
        ns = m[0],
        nsj = ns.split("-"),
        timeValue = nsj.length > 3 ? 3 : 2,
        n = nsj[timeValue],
        o = n.trim(),
        p = new Date(o),
        q = n.substring(0, 7),
        r = o.substring(0, 2),
        s = o.substring(2, 5),
        t = o.substring(5, 7),
        u = c(t + s + r),
        v = new Date(u),
        w = new Date(),
        x = v.getDate() - 95,
        y = new Date().toISOString().slice(0, 10),
        z = new Date(u).toISOString().slice(0, 10),
        A = 0;
      if ((z >= y && (A = 1), 0 == A)) {
        var B = d(k);
        if (null == g || "undefined" == g)
          var C = 2,
            D = new Date(1e3 * e.from).toISOString().slice(0, 10),
            E = new Date(1e3 * e.to).toISOString().slice(0, 10);
        else {
          var C = 2;
          if ("" != B)
            var D = B,
              E = new Date(1e3 * e.to).toISOString().slice(0, 10);
          else
            var D = new Date(1e3 * e.from).toISOString().slice(0, 10),
              E = new Date(1e3 * e.to).toISOString().slice(0, 10);
        }
      } else {
        var B = d(k);
        if (null == g || "undefined" == g)
          var C = 1,
            D = new Date(1e3 * e.from).toISOString().slice(0, 10),
            E = new Date(1e3 * e.to).toISOString().slice(0, 10);
        else
          var C = 0,
            F = Date.parse(B) / 1e3,
            D = B,
            E = new Date(1e3 * e.to).toISOString().slice(0, 10);
      }
      const G = {
        symbol: k || "",
        resolution: b,
        from: D,
        to: E,
        u: userName,
        sid: sid,
        q1: q1,
        q2: q2,
        mode: mode,
        DataRequest: C,
        firstDataRequest: j,
      };
      // if(j) {
      return (
        void 0 !== e.countBack && (G.countback = e.countBack),
        void 0 !== a.currency_code && (G.currencyCode = a.currency_code),
        void 0 !== a.unit_id && (G.unitId = a.unit_id),
        new Promise((a, b) => {
          if (j == true || G.countback == 50) {
            this._requester
              .sendRequest(
                this._datafeedUrl,
                "opt/getdata_Straddle_Chart_Tv_Charts_Daily_v3.php",
                G
              )
              .then((b) => {
                if ("ok" !== b.s && "no_data" !== b.s)
                  return void g([], { noData: !0 });
                const c = [],
                  d = { noData: !1 };
                if ("no_data" === b.s)
                  (d.noData = !0), (d.nextTime = b.nextTime);
                else {
                  const a = void 0 !== b.v,
                    d = void 0 !== b.o;
                  // console.log("Length: ", b.t.length);
                  // if(b.t.length < 330) {
                  //     return console.log(b.t.length);
                  // } else {
                  for (let e = 0; e < b.t.length; ++e) {
                    const f = {
                      time: 1e3 * b.t[e],
                      close: parseFloat(b.c[e]),
                      open: parseFloat(b.c[e]),
                      high: parseFloat(b.c[e]),
                      low: parseFloat(b.c[e]),
                    };
                    d &&
                      ((f.open = parseFloat(b.o[e])),
                      (f.high = parseFloat(b.h[e])),
                      (f.low = parseFloat(b.l[e]))),
                      a && (f.volume = parseFloat(b.v[e])),
                      c.push(f);
                    // }
                  }
                }
                a({ bars: c, meta: d });
              })
              .catch((a) => {
                // alert("Data Not Available");
                const c = f(a);
                console.warn(`HistoryProvider: getBars() failed, error=${c}`),
                  b(c);
              });
          } else {
            this._requester
              .sendRequest(
                this._datafeedUrl,
                "opt/getdata_Straddle_Chart_Tv_Charts_Daily.php",
                G
              )
              .then((b) => {
                if ("ok" !== b.s && "no_data" !== b.s)
                  return void g([], { noData: !0 });
                const c = [],
                  d = { noData: !0 };
                if ("no_data" === b.s)
                  (d.noData = !0), (d.nextTime = b.nextTime);
                else {
                  const a = void 0 !== b.v,
                    d = void 0 !== b.o;
                  // console.log("Length: ", b.t.length);
                  for (let e = 0; e > b.t.length; ++e) {
                    const f = {
                      time: 1e3 * b.t[e],
                      close: parseFloat(b.c[e]),
                      open: parseFloat(b.c[e]),
                      high: parseFloat(b.c[e]),
                      low: parseFloat(b.c[e]),
                    };
                    d &&
                      ((f.open = parseFloat(b.o[e])),
                      (f.high = parseFloat(b.h[e])),
                      (f.low = parseFloat(b.l[e]))),
                      a && (f.volume = parseFloat(b.v[e])),
                      c.push(f);
                  }
                }
                a({ bars: c, meta: d });
              });
          }
        })
      );
    }
  }
  class m {
    constructor(a, b) {
      (this._subscribers = {}),
        (this._requestsPending = 0),
        (this._historyProvider = a),
        setInterval(this._updateData.bind(this), b);
    }
    subscribeBars(a, b, c, d) {
      this._subscribers.hasOwnProperty(d) ||
        ((this._subscribers[d] = {
          lastBarTime: null,
          listener: c,
          resolution: b,
          symbolInfo: a,
        }),
        e(`DataPulseProvider: subscribed for #${d} - {${a.name}, ${b}}`));
    }
    unsubscribeBars(a) {
      delete this._subscribers[a];
    }
    _updateData() {
      if (!(0 < this._requestsPending))
        for (const a in ((this._requestsPending = 0), this._subscribers))
          (this._requestsPending += 1),
            this._updateDataForSubscriber(a)
              .then(() => {
                (this._requestsPending -= 1),
                  e(
                    `DataPulseProvider: data for #${a} updated successfully, pending=${this._requestsPending}`
                  );
              })
              .catch((b) => {
                (this._requestsPending -= 1),
                  e(
                    `DataPulseProvider: data for #${a} updated with error=${f(
                      b
                    )}, pending=${this._requestsPending}`
                  );
              });
    }
    _updateDataForSubscriber(a) {
      const b = this._subscribers[a],
        c = parseInt((Date.now() / 1e3).toString()),
        d = c - g(b.resolution, 10);
      return this._historyProvider
        .getBars(b.symbolInfo, b.resolution, {
          from: d,
          to: c,
          countBack: 50,
          firstDataRequest: !1,
        })
        .then((b) => {
          this._onSubscriberDataReceived(a, b);
        });
    }
    _onSubscriberDataReceived(a, b) {
      if (!this._subscribers.hasOwnProperty(a)) return;
      const c = b.bars;
      if (0 === c.length) return;
      const d = c[c.length - 1],
        e = this._subscribers[a];
      if (!(null !== e.lastBarTime && d.time < e.lastBarTime)) {
        const a = null !== e.lastBarTime && d.time > e.lastBarTime;
        if (a) {
          if (2 > c.length)
            throw new Error(
              "Not enough bars in history for proper pulse update. Need at least 2."
            );
          const a = c[c.length - 2];
          e.listener(a);
        }
        (e.lastBarTime = d.time), e.listener(d);
      }
    }
  }
  class n {
    constructor(a) {
      (this._subscribers = {}),
        (this._requestsPending = 0),
        (this._quotesProvider = a),
        setInterval(this._updateQuotes.bind(this, 1), 3e4);
    }
    subscribeQuotes(a, b, c, d) {
      this._subscribers[d] = { symbols: a, fastSymbols: b, listener: c };
    }
    unsubscribeQuotes(a) {
      delete this._subscribers[a];
    }
    _updateQuotes(a) {
      if (!(0 < this._requestsPending))
        for (const b in this._subscribers) {
          this._requestsPending++;
          const c = this._subscribers[b];
          this._quotesProvider
            .getQuotes(1 === a ? c.fastSymbols : c.symbols)
            .then((d) => {
              this._requestsPending--,
                this._subscribers.hasOwnProperty(b) &&
                  (c.listener(d),
                  e(
                    `QuotesPulseProvider: data for #${b} (${a}) updated successfully, pending=${this._requestsPending}`
                  ));
            })
            .catch((c) => {
              this._requestsPending--,
                e(
                  `QuotesPulseProvider: data for #${b} (${a}) updated with error=${f(
                    c
                  )}, pending=${this._requestsPending}`
                );
            });
        }
    }
  }
  class o {
    constructor(a, b, c) {
      (this._exchangesList = ["NYSE", "FOREX", "AMEX"]),
        (this._symbolsInfo = {}),
        (this._symbolsList = []),
        (this._datafeedUrl = a),
        (this._datafeedSupportedResolutions = b),
        (this._requester = c),
        (this._readyPromise = this._init()),
        this._readyPromise.catch((a) => {
          console.error(`SymbolsStorage: Cannot init, error=${a.toString()}`);
        });
    }
    resolveSymbol(a, b, c) {
      return this._readyPromise.then(() => {
        const d = this._symbolsInfo[i(a, b, c)];
        return void 0 === d
          ? Promise.reject("invalid symbol")
          : Promise.resolve(d);
      });
    }
    searchSymbols(a, b, c, d) {
      return this._readyPromise.then(() => {
        const e = [],
          f = 0 === a.length;
        a = a.toUpperCase();
        for (const d of this._symbolsList) {
          const g = this._symbolsInfo[d];
          if (void 0 === g) continue;
          if (0 < c.length && g.type !== c) continue;
          if (b && 0 < b.length && g.exchange !== b) continue;
          const h = g.name.toUpperCase().indexOf(a),
            i = g.description.toUpperCase().indexOf(a);
          if (f || 0 <= h || 0 <= i) {
            const a = e.some((a) => a.symbolInfo === g);
            if (!a) {
              const a = 0 <= h ? h : 8e3 + i;
              e.push({ symbolInfo: g, weight: a });
            }
          }
        }
        const g = e
          .sort((a, b) => a.weight - b.weight)
          .slice(0, d)
          .map((a) => {
            const b = a.symbolInfo;
            return {
              symbol: b.name,
              full_name: b.full_name,
              description: b.description,
              exchange: b.exchange,
              params: [],
              type: b.type,
              ticker: b.name,
            };
          });
        return Promise.resolve(g);
      });
    }
    _init() {
      const a = [],
        b = {};
      for (const c of this._exchangesList)
        b[c] || ((b[c] = !0), a.push(this._requestExchangeData(c)));
      return Promise.all(a).then(() => {
        this._symbolsList.sort();
      });
    }
    _requestExchangeData(a) {
      return new Promise((b, c) => {
        this._requester
          .sendRequest(
            this._datafeedUrl,
            "opt/Symbols_Straddle_TV_Charts_v23_Hiekin.php",
            { group: a }
          )
          .then((d) => {
            try {
              this._onExchangeDataReceived(a, d);
            } catch (a) {
              return void c(a);
            }
            b();
          })
          .catch((c) => {
            e(
              `SymbolsStorage: Request data for exchange '${a}' failed, reason=${f(
                c
              )}`
            ),
              b();
          });
      });
    }
    _onExchangeDataReceived(a, b) {
      let c = 0;
      try {
        const a = b.symbol.length,
          d = b.ticker !== void 0;
        for (; c < a; ++c) {
          const a = b.symbol[c],
            e = h(b, "exchange-listed", c),
            f = h(b, "exchange-traded", c),
            g = f + ":" + a,
            k = h(b, "currency-code", c),
            l = h(b, "unit-id", c),
            m = d ? h(b, "ticker", c) : a,
            n = {
              ticker: m,
              name: a,
              base_name: [e + ":" + a],
              full_name: g,
              listed_exchange: e,
              exchange: f,
              currency_code: k,
              original_currency_code: h(b, "original-currency-code", c),
              unit_id: l,
              original_unit_id: h(b, "original-unit-id", c),
              unit_conversion_types: h(b, "unit-conversion-types", c, !0),
              description: h(b, "description", c),
              has_intraday: j(h(b, "has-intraday", c), !1),
              has_no_volume: j(h(b, "has-no-volume", c), !1),
              minmov: h(b, "minmovement", c) || h(b, "minmov", c) || 0,
              minmove2: h(b, "minmove2", c) || h(b, "minmov2", c),
              fractional: h(b, "fractional", c),
              pricescale: h(b, "pricescale", c),
              type: h(b, "type", c),
              session: h(b, "session-regular", c),
              timezone: h(b, "timezone", c),
              supported_resolutions: j(
                h(b, "supported-resolutions", c, !0),
                this._datafeedSupportedResolutions
              ),
              has_daily: j(h(b, "has-daily", c), !0),
              intraday_multipliers: j(h(b, "intraday-multipliers", c, !0), [
                "1",
                "5",
                "15",
                "30",
                "60",
              ]),
              has_weekly_and_monthly: h(b, "has-weekly-and-monthly", c),
              has_empty_bars: h(b, "has-empty-bars", c),
              volume_precision: j(h(b, "volume-precision", c), 0),
              format: "price",
            };
          (this._symbolsInfo[m] = n),
            (this._symbolsInfo[a] = n),
            (this._symbolsInfo[g] = n),
            (k !== void 0 || l !== void 0) &&
              ((this._symbolsInfo[i(m, k, l)] = n),
              (this._symbolsInfo[i(a, k, l)] = n),
              (this._symbolsInfo[i(g, k, l)] = n)),
            this._symbolsList.push(a);
        }
      } catch (d) {
        throw new Error(
          `SymbolsStorage: API error when processing exchange ${a} symbol #${c} (${b.symbol[c]}): ${d.message}`
        );
      }
    }
  }
  class p {
    constructor(a, b, c, d = 60000) {
      (this._configuration = k()),
        (this._symbolsStorage = null),
        (this._datafeedURL = a),
        (this._requester = c),
        (this._historyProvider = new l(a, this._requester)),
        (this._quotesProvider = b),
        (this._dataPulseProvider = new m(this._historyProvider, d)),
        (this._quotesPulseProvider = new n(this._quotesProvider)),
        (this._configurationReadyPromise = this._requestConfiguration().then(
          (a) => {
            null === a && (a = k()), this._setupWithConfiguration(a);
          }
        ));
    }
    onReady(a) {
      this._configurationReadyPromise.then(() => {
        a(this._configuration);
      });
    }
    getQuotes(a, b, c) {
      this._quotesProvider.getQuotes(a).then(b).catch(c);
    }
    subscribeQuotes(a, b, c, d) {
      this._quotesPulseProvider.subscribeQuotes(a, b, c, d);
    }
    unsubscribeQuotes(a) {
      this._quotesPulseProvider.unsubscribeQuotes(a);
    }
    getServerTime(a) {
      this._configuration.supports_time &&
        this._send("opt/time_TV.php")
          .then((b) => {
            const c = parseInt(b);
            isNaN(c) || a(c);
          })
          .catch((a) => {
            e(`UdfCompatibleDatafeed: Fail to load server time, error=${f(a)}`);
          });
    }
    searchSymbols(a, b, c, d) {
      var g,
        h = new Date().toISOString().slice(0, 10);
      if (
        ((g =
          h > default_expiry_date
            ? "XX" == default_option_type
              ? "Futures_Hist"
              : "Options_Hist"
            : "XX" == default_option_type
            ? "Futures_Latest"
            : "Options_Latest"),
        this._configuration.supports_search)
      ) {
        const h = {
          limit: 30,
          query: a.toUpperCase(),
          type: c,
          exchange: b,
          default_symbol_type_val: g,
        };
        this._send("opt/Search_FNO_TV_optimized_v2.php", h)
          .then((a) =>
            void 0 === a.s
              ? void d(a)
              : (e(`UdfCompatibleDatafeed: search symbols error=${a.errmsg}`),
                void d([]))
          )
          .catch((b) => {
            e(
              `UdfCompatibleDatafeed: Search symbols for '${a}' failed. Error=${f(
                b
              )}`
            ),
              d([]);
          });
      } else {
        if (null === this._symbolsStorage)
          throw new Error(
            "UdfCompatibleDatafeed: inconsistent configuration (symbols storage)"
          );
        this._symbolsStorage
          .searchSymbols(a, b, c, 30)
          .then(d)
          .catch(d.bind(null, []));
      }
    }
    resolveSymbol(a, b, c, d) {
      function g(a) {
        b(a);
      }
      const h = d && d.currencyCode,
        i = d && d.unitId;
      if (!this._configuration.supports_group_request) {
        const b = { symbol: a };
        h !== void 0 && (b.currencyCode = h),
          i !== void 0 && (b.unitId = i),
          this._send("opt/Symbols_Straddle_TV_Charts_v23_Hiekin.php", b)
            .then((a) => {
              a.s === void 0 ? g(a) : c("unknown_symbol");
            })
            .catch((a) => {
              e(`UdfCompatibleDatafeed: Error resolving symbol: ${f(a)}`),
                c("unknown_symbol");
            });
      } else {
        if (null === this._symbolsStorage)
          throw new Error(
            "UdfCompatibleDatafeed: inconsistent configuration (symbols storage)"
          );
        this._symbolsStorage.resolveSymbol(a, h, i).then(g).catch(c);
      }
    }
    getBars(a, b, c, d, e, f) {
      this._historyProvider
        .getBars(a, b, c, e)
        .then((a) => {
          d(a.bars, a.meta);
        })
        .catch(f);
    }
    subscribeBars(a, b, c, d) {
      this._dataPulseProvider.subscribeBars(a, b, c, d);
    }
    unsubscribeBars(a) {
      this._dataPulseProvider.unsubscribeBars(a);
    }
    _requestConfiguration() {
      return this._send("opt/configTV.php").catch(
        (a) => (
          e(
            `UdfCompatibleDatafeed: Cannot get datafeed configuration - use default, error=${f(
              a
            )}`
          ),
          null
        )
      );
    }
    _send(a, b) {
      return this._requester.sendRequest(this._datafeedURL, a, b);
    }
    _setupWithConfiguration(a) {
      if (
        ((this._configuration = a),
        void 0 === a.exchanges && (a.exchanges = []),
        !a.supports_search && !a.supports_group_request)
      )
        throw new Error(
          "Unsupported datafeed configuration. Must either support search, or support group request"
        );
      (a.supports_group_request || !a.supports_search) &&
        (this._symbolsStorage = new o(
          this._datafeedURL,
          a.supported_resolutions || [],
          this._requester
        )),
        e(`UdfCompatibleDatafeed: Initialized with ${JSON.stringify(a)}`);
    }
  }
  class q {
    constructor(a, b) {
      (this._datafeedUrl = a), (this._requester = b);
    }
    getQuotes(a) {
      return new Promise((b, c) => {
        this._requester
          .sendRequest(this._datafeedUrl, "opt/WatchList_TV_Charts_v1.php", {
            symbols: a,
          })
          .then((a) => {
            "ok" === a.s ? b(a.d) : c(a.errmsg);
          })
          .catch((a) => {
            const b = f(a);
            c(`network error: ${b}`);
          });
      });
    }
  }
  class r {
    constructor(a) {
      a && (this._headers = a);
    }
    sendRequest(a, b, c) {
      if (void 0 !== c) {
        const a = Object.keys(c);
        0 !== a.length && (b += "?"),
          (b += a
            .map((a) => `${encodeURIComponent(a)}=${encodeURIComponent(c[a])}`)
            .join("&"));
      }
      const d = { credentials: "same-origin" };
      return (
        void 0 !== this._headers && (d.headers = this._headers),
        fetch(`${a}/${b}`, d)
          .then((a) => a.text())
          .then((a) => JSON.parse(a))
      );
    }
  }
  (a.UDFCompatibleDatafeed = class a extends p {
    constructor(a, b = 30000) {
      const c = new r(),
        d = new q(a, c);
      super(a, d, c, b);
    }
  }),
    Object.defineProperty(a, "__esModule", { value: !0 });
});
